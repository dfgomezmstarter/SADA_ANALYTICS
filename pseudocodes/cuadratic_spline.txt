


Input: Matrix A, vector B
Output: Steps of making the cholesky factorization and the answer to the system



	return error detrminant equals 0
    if x or y has duplicates:
        return error
    end if

    if lenght of x is not equals to lenght of y:
        return error
    end if

    set n = lenght of x
    set m = (n - 1) * 3
    set A = matrix[m][m]
    set B = vector[m]
    set A[0][0] = x[0] ^2
    set A[0][1] = x[0]
    set A[0][2] = 1
    set B[0] = y[0]
    #interpolation conditions
    For i = 0,..., n − 1 
        set A[i+1][3*(i+1)-3] = math.pow(x[i+1], 2)
        set A[i+1][3*(i+1)-2] = x[i+1]
        set A[i+1][3*(i+1)-1] = 1
        set B[i+1] = y[i+1]
    end for
    #continuity conditions
    For i = 1,..., n − 1 
        set  A[n-1+i][3*i-3] = math.pow(x[i], 2)
        set  A[n-1+i][3*i-2] = x[i]
        set  A[n-1+i][3*i-1] = 1
        set  A[n-1+i][3*i] = -math.pow(x[i], 2)
        set  A[n-1+i][3*i+1] = -x[i]
        set  A[n-1+i][3*i+2] = -1
        set  B[n-1+i] = 0
    #softness condition
    for i in range(1, n-1):
        set A[2*n-3+i][3*i-3] = 2 * x[i]
        A[2*n-3+i][3*i-2] = 1
        A[2*n-3+i][3*i-1] = 0
        A[2*n-3+i][3*i] = -2 * x[i]
        A[2*n-3+i][3*i+1] = -1
        A[2*n-3+i][3*i+2] = 0
        B[2*n-3+i] = 0
    
    A[m-1][0] = 2
    B[m-1] = 0
    print("A")
    A = np.array(A)
    print(A)
    print("B")
    print(B)
    x = np.linalg.solve(A, B)
    print(x)

    # for i in range(len(x)/3):
    #     print(str(x[i*3])
def list_has_duplicates(input_list):
    list_set = set(input_list)
    contains_duplicates = len(list_set) != len(input_list)
    return contains_duplicates
cuadratic_spline([-1,0,3,4],[15.5,3,8,1])
